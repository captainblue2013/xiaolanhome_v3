## 背景
javascript 里，我们一般用setInterval方法来实现一个定时循环业务，函数原型如下：

```javascript
setInterval(function(){
    //这里放你要执行的业务，后面的参数是时间，单位毫秒，1秒=1000毫秒，比如
    console.log('哈');
},5000);
```

上面的代码，单独执行的时候，效果诚然是如我们所想的：

```javascript
哈    哈    哈    哈    （循环 ）
```
# 但是，问题来了。
`javascript 是单进程的，即时是在浏览器还是在服务端node，这时候问题来了。`而 `异步操作次序的不确定性`，一个程序里不可能仅仅这几行代码，有可能出现一个情况，
就是前一个callback（其他行为，比如写入一个大文件）执行的时间很长，回调队列处于阻塞状态，
而你的`哈`正在以每5秒一个的频率进入队列。然后你可能看到的是这样的：

```javascript
哈    哈  （某长时间操作） 哈哈哈哈哈哈    哈    哈    哈   ......
```

中间某一段，因为回调堆积，引起的瞬间打印多个`哈`,这并不是我们想看到的。

`===================================================================`
# 怎么办呢？
我们可以用 `setTimeout`来实现，它的参数列表和上面的一样，区别是这个逻辑只执行一次。
惯例先上代码：

```javascript
//先把逻辑定义成一个函数
var do_sth = function(){
    console.log('哈');
    //然后用神奇的setTimeout,还是5秒
    setTimeout(function(){
        //注意了，调用自己
        do_sth();
    },5000);
};
```

以上代码就是，输出了第一个`哈`以后，再申请下一个延时操作。
这样，就能够让每个`哈`一个跟一个的输出，而不会出现回调堆积的情况。
## 新技能GET！！
后话：
用这样的方法，可能会出现两次间隔超出5秒的情况，其实上面两种都会有这种情况。
用setTimeout的意义在于解决堆积，避免一次性同时触发（尤其是一些IO操作）。
